<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>漏洞预警|Windows 7 Meltdown 补丁发现漏洞，允许任意进程读写内核 - F0rmat的博客 | 专注于网络攻防和信息安全</title>

<meta name="description" content="前言 今晚本来想养生睡个早觉的，睡前浏览了下twitter，看到大佬的高危漏洞，看着有点好笑，微软拿起自己的石头砸自己的脚操作哈哈，这个洞在27号就已经出来了。  今年1月份英特尔确认了在自家CPU中发现两个安全漏洞，而这些漏洞将会使得数十亿设备面临受到攻击的风险“Meltdown”和“Spectre”两个漏洞让不少人感觉恐慌，因为他们发现这些漏洞几乎影响到过去20年制造的每一种计算设备，无论是手机还是个人电脑。他们允许恶意程序窃取在受影响机器上处理的敏感数据。
 别以为安装这个官方的补丁就很安全了，更糟糕的事情来了，这个漏洞可以允许任意进程读写内核。
总体崩溃? 你认为Meltdown糟糕吗？未授权的应用程序能够以每秒兆字节的速度读取内核内存不是一件好事。
从1月份开始迎接Windows 7 Meltdown补丁。它停止了Meltdown，但是开辟了一条更糟的漏洞&amp;hellip;&amp;hellip;它允许任何进程以每秒千兆字节的速度读取完整的内存内容，噢 - 也可以写入任意内存。
没有fancy的利用需要。 Windows 7已经将所需内存映射到每个正在运行的进程中。开发仅仅是读写已映射进程内虚拟内存的问题。没有fancy的API或系统调用要求 - 只是标准的读取和写入！ 由于磁盘传输速度的原因，以超过4GB / s的速度访问内存，转储到磁盘的速度较慢
这怎么可能？ 简而言之 - 在PML4自引用条目中，User/Supervisor权限位已设置为User。这使得页表在每个进程中都可用于用户模式代码。页面表通常只能由内核本身访问。
PML4是4级内存页表层次结构的基础，CPU内存管理单元（MMU）用来将进程的虚拟地址转换为RAM中的物理内存地址。欲了解更多有关寻呼的深入信息，请看看获得物理：极端滥用基于英特尔的寻呼系统 - 第1部分和第2部分。 位于偏移量0xF68且值为0x0000000062100867的PML4自引用条目。
Windows在这个最重要的PML4页表中有一个特殊的条目，它引用了它自己的一个自引用条目。在Windows 7中，PML4自引用固定在位置0x1ED，偏移量0xF68（在Windows 10中随机化）。这意味着PML4将始终映射到虚拟内存中的地址0xFFFFF6FB7DBED000。这通常是一个内核地址（Supervisor）提供的内存地址。由于权限位被错误地设置为用户，这意味着PML4被映射到每个进程并且可用于在用户模式下执行的代码。
作为用户模式读/写页面映射到每个进程的“内核地址”内存地址。.
一旦对页表进行读/写访问，除非通过用于虚拟化的扩展页表（EPT）进行额外保护，否则访问整个物理内存将非常容易。所有人都必须将自己的页面表项（PTE）写入页表以访问任意的物理内存。
PML4e 0x0000000062100867中的最后一个&#39;7&#39;（来自上面的例子）表示位0,1,2被设置，这意味着它可以按照Intel手册中的说明进行存在，可写和用户模式访问。 摘自英特尔手册，如果位2设置为&#39;1&#39;，则允许用户模式访问。
我可以自己尝试一下吗？ 是的，一点没错。 该技术已被添加为PCILeech直接存储器访问攻击工具包的内存采集设备。 只需下载PCILeech并使用设备类型执行即可：-device totalmeltdown在易受攻击的Windows 7系统上。
使用以下命令将内存转储到文件：
pcileech.exe dump -out memorydump.raw -device totalmeltdown -v -force 如果安装了Dokany文件系统驱动程序，则应该能够将正在运行的进程挂载为内存进程文件系统中的文件和文件夹 - 将内核的虚拟内存和进程的内存作为读/写进行安装。
要挂载进程，请执行以下命令：
pcileech.exe mount -device totalmeltdown 如果您暂时卸载最新版本以测试此漏洞，请记住重新安装安全更新。
易受攻击的系统被“利用”，运行中的进程被PCILeech挂载。进程内存映射和PML4被访问。
我的系统很脆弱吗？ 只有使用2018-01或2018-02补丁修补的Windows 7 x64系统才容易受到攻击。如果您的系统自2017年12月以来没有进行过修补，或者修补了2018-03修补程序或更高版本，那么它将是安全的。
其他Windows版本 - 例如Windows 10或8.1，对于这个问题是完全安全的，并且从未受到它的影响。" /><meta name="keywords"
  content="F0rmat, 信息安全, 网络安全, 红蓝攻防, 渗透测试, bypass, waf, 注入, 黑客" />
  <meta name="referrer" content="no-referrer" />


<link rel="stylesheet" href="https://getshe11.com/css/main.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/src/css/lightgallery.css">



<meta property="og:title" content="漏洞预警|Windows 7 Meltdown 补丁发现漏洞，允许任意进程读写内核" />
<meta property="og:description" content="前言 今晚本来想养生睡个早觉的，睡前浏览了下twitter，看到大佬的高危漏洞，看着有点好笑，微软拿起自己的石头砸自己的脚操作哈哈，这个洞在27号就已经出来了。  今年1月份英特尔确认了在自家CPU中发现两个安全漏洞，而这些漏洞将会使得数十亿设备面临受到攻击的风险“Meltdown”和“Spectre”两个漏洞让不少人感觉恐慌，因为他们发现这些漏洞几乎影响到过去20年制造的每一种计算设备，无论是手机还是个人电脑。他们允许恶意程序窃取在受影响机器上处理的敏感数据。
 别以为安装这个官方的补丁就很安全了，更糟糕的事情来了，这个漏洞可以允许任意进程读写内核。
总体崩溃? 你认为Meltdown糟糕吗？未授权的应用程序能够以每秒兆字节的速度读取内核内存不是一件好事。
从1月份开始迎接Windows 7 Meltdown补丁。它停止了Meltdown，但是开辟了一条更糟的漏洞&hellip;&hellip;它允许任何进程以每秒千兆字节的速度读取完整的内存内容，噢 - 也可以写入任意内存。
没有fancy的利用需要。 Windows 7已经将所需内存映射到每个正在运行的进程中。开发仅仅是读写已映射进程内虚拟内存的问题。没有fancy的API或系统调用要求 - 只是标准的读取和写入！ 由于磁盘传输速度的原因，以超过4GB / s的速度访问内存，转储到磁盘的速度较慢
这怎么可能？ 简而言之 - 在PML4自引用条目中，User/Supervisor权限位已设置为User。这使得页表在每个进程中都可用于用户模式代码。页面表通常只能由内核本身访问。
PML4是4级内存页表层次结构的基础，CPU内存管理单元（MMU）用来将进程的虚拟地址转换为RAM中的物理内存地址。欲了解更多有关寻呼的深入信息，请看看获得物理：极端滥用基于英特尔的寻呼系统 - 第1部分和第2部分。 位于偏移量0xF68且值为0x0000000062100867的PML4自引用条目。
Windows在这个最重要的PML4页表中有一个特殊的条目，它引用了它自己的一个自引用条目。在Windows 7中，PML4自引用固定在位置0x1ED，偏移量0xF68（在Windows 10中随机化）。这意味着PML4将始终映射到虚拟内存中的地址0xFFFFF6FB7DBED000。这通常是一个内核地址（Supervisor）提供的内存地址。由于权限位被错误地设置为用户，这意味着PML4被映射到每个进程并且可用于在用户模式下执行的代码。
作为用户模式读/写页面映射到每个进程的“内核地址”内存地址。.
一旦对页表进行读/写访问，除非通过用于虚拟化的扩展页表（EPT）进行额外保护，否则访问整个物理内存将非常容易。所有人都必须将自己的页面表项（PTE）写入页表以访问任意的物理内存。
PML4e 0x0000000062100867中的最后一个&#39;7&#39;（来自上面的例子）表示位0,1,2被设置，这意味着它可以按照Intel手册中的说明进行存在，可写和用户模式访问。 摘自英特尔手册，如果位2设置为&#39;1&#39;，则允许用户模式访问。
我可以自己尝试一下吗？ 是的，一点没错。 该技术已被添加为PCILeech直接存储器访问攻击工具包的内存采集设备。 只需下载PCILeech并使用设备类型执行即可：-device totalmeltdown在易受攻击的Windows 7系统上。
使用以下命令将内存转储到文件：
pcileech.exe dump -out memorydump.raw -device totalmeltdown -v -force 如果安装了Dokany文件系统驱动程序，则应该能够将正在运行的进程挂载为内存进程文件系统中的文件和文件夹 - 将内核的虚拟内存和进程的内存作为读/写进行安装。
要挂载进程，请执行以下命令：
pcileech.exe mount -device totalmeltdown 如果您暂时卸载最新版本以测试此漏洞，请记住重新安装安全更新。
易受攻击的系统被“利用”，运行中的进程被PCILeech挂载。进程内存映射和PML4被访问。
我的系统很脆弱吗？ 只有使用2018-01或2018-02补丁修补的Windows 7 x64系统才容易受到攻击。如果您的系统自2017年12月以来没有进行过修补，或者修补了2018-03修补程序或更高版本，那么它将是安全的。
其他Windows版本 - 例如Windows 10或8.1，对于这个问题是完全安全的，并且从未受到它的影响。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://getshe11.com/post/vulnerability-alert_windows-7-meltdown-patch-discovery-vulnerability-allows-any-process-to-read-and-write-kernels/" />
<meta property="article:published_time" content="2018-03-29T10:16:39+00:00" />
<meta property="article:modified_time" content="2018-03-29T10:16:39+00:00" />
<meta itemprop="name" content="漏洞预警|Windows 7 Meltdown 补丁发现漏洞，允许任意进程读写内核">
<meta itemprop="description" content="前言 今晚本来想养生睡个早觉的，睡前浏览了下twitter，看到大佬的高危漏洞，看着有点好笑，微软拿起自己的石头砸自己的脚操作哈哈，这个洞在27号就已经出来了。  今年1月份英特尔确认了在自家CPU中发现两个安全漏洞，而这些漏洞将会使得数十亿设备面临受到攻击的风险“Meltdown”和“Spectre”两个漏洞让不少人感觉恐慌，因为他们发现这些漏洞几乎影响到过去20年制造的每一种计算设备，无论是手机还是个人电脑。他们允许恶意程序窃取在受影响机器上处理的敏感数据。
 别以为安装这个官方的补丁就很安全了，更糟糕的事情来了，这个漏洞可以允许任意进程读写内核。
总体崩溃? 你认为Meltdown糟糕吗？未授权的应用程序能够以每秒兆字节的速度读取内核内存不是一件好事。
从1月份开始迎接Windows 7 Meltdown补丁。它停止了Meltdown，但是开辟了一条更糟的漏洞&hellip;&hellip;它允许任何进程以每秒千兆字节的速度读取完整的内存内容，噢 - 也可以写入任意内存。
没有fancy的利用需要。 Windows 7已经将所需内存映射到每个正在运行的进程中。开发仅仅是读写已映射进程内虚拟内存的问题。没有fancy的API或系统调用要求 - 只是标准的读取和写入！ 由于磁盘传输速度的原因，以超过4GB / s的速度访问内存，转储到磁盘的速度较慢
这怎么可能？ 简而言之 - 在PML4自引用条目中，User/Supervisor权限位已设置为User。这使得页表在每个进程中都可用于用户模式代码。页面表通常只能由内核本身访问。
PML4是4级内存页表层次结构的基础，CPU内存管理单元（MMU）用来将进程的虚拟地址转换为RAM中的物理内存地址。欲了解更多有关寻呼的深入信息，请看看获得物理：极端滥用基于英特尔的寻呼系统 - 第1部分和第2部分。 位于偏移量0xF68且值为0x0000000062100867的PML4自引用条目。
Windows在这个最重要的PML4页表中有一个特殊的条目，它引用了它自己的一个自引用条目。在Windows 7中，PML4自引用固定在位置0x1ED，偏移量0xF68（在Windows 10中随机化）。这意味着PML4将始终映射到虚拟内存中的地址0xFFFFF6FB7DBED000。这通常是一个内核地址（Supervisor）提供的内存地址。由于权限位被错误地设置为用户，这意味着PML4被映射到每个进程并且可用于在用户模式下执行的代码。
作为用户模式读/写页面映射到每个进程的“内核地址”内存地址。.
一旦对页表进行读/写访问，除非通过用于虚拟化的扩展页表（EPT）进行额外保护，否则访问整个物理内存将非常容易。所有人都必须将自己的页面表项（PTE）写入页表以访问任意的物理内存。
PML4e 0x0000000062100867中的最后一个&#39;7&#39;（来自上面的例子）表示位0,1,2被设置，这意味着它可以按照Intel手册中的说明进行存在，可写和用户模式访问。 摘自英特尔手册，如果位2设置为&#39;1&#39;，则允许用户模式访问。
我可以自己尝试一下吗？ 是的，一点没错。 该技术已被添加为PCILeech直接存储器访问攻击工具包的内存采集设备。 只需下载PCILeech并使用设备类型执行即可：-device totalmeltdown在易受攻击的Windows 7系统上。
使用以下命令将内存转储到文件：
pcileech.exe dump -out memorydump.raw -device totalmeltdown -v -force 如果安装了Dokany文件系统驱动程序，则应该能够将正在运行的进程挂载为内存进程文件系统中的文件和文件夹 - 将内核的虚拟内存和进程的内存作为读/写进行安装。
要挂载进程，请执行以下命令：
pcileech.exe mount -device totalmeltdown 如果您暂时卸载最新版本以测试此漏洞，请记住重新安装安全更新。
易受攻击的系统被“利用”，运行中的进程被PCILeech挂载。进程内存映射和PML4被访问。
我的系统很脆弱吗？ 只有使用2018-01或2018-02补丁修补的Windows 7 x64系统才容易受到攻击。如果您的系统自2017年12月以来没有进行过修补，或者修补了2018-03修补程序或更高版本，那么它将是安全的。
其他Windows版本 - 例如Windows 10或8.1，对于这个问题是完全安全的，并且从未受到它的影响。">
<meta itemprop="datePublished" content="2018-03-29T10:16:39+00:00" />
<meta itemprop="dateModified" content="2018-03-29T10:16:39+00:00" />
<meta itemprop="wordCount" content="85">



<meta itemprop="keywords" content="漏洞预警,补丁,Meltdown," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="漏洞预警|Windows 7 Meltdown 补丁发现漏洞，允许任意进程读写内核"/>
<meta name="twitter:description" content="前言 今晚本来想养生睡个早觉的，睡前浏览了下twitter，看到大佬的高危漏洞，看着有点好笑，微软拿起自己的石头砸自己的脚操作哈哈，这个洞在27号就已经出来了。  今年1月份英特尔确认了在自家CPU中发现两个安全漏洞，而这些漏洞将会使得数十亿设备面临受到攻击的风险“Meltdown”和“Spectre”两个漏洞让不少人感觉恐慌，因为他们发现这些漏洞几乎影响到过去20年制造的每一种计算设备，无论是手机还是个人电脑。他们允许恶意程序窃取在受影响机器上处理的敏感数据。
 别以为安装这个官方的补丁就很安全了，更糟糕的事情来了，这个漏洞可以允许任意进程读写内核。
总体崩溃? 你认为Meltdown糟糕吗？未授权的应用程序能够以每秒兆字节的速度读取内核内存不是一件好事。
从1月份开始迎接Windows 7 Meltdown补丁。它停止了Meltdown，但是开辟了一条更糟的漏洞&hellip;&hellip;它允许任何进程以每秒千兆字节的速度读取完整的内存内容，噢 - 也可以写入任意内存。
没有fancy的利用需要。 Windows 7已经将所需内存映射到每个正在运行的进程中。开发仅仅是读写已映射进程内虚拟内存的问题。没有fancy的API或系统调用要求 - 只是标准的读取和写入！ 由于磁盘传输速度的原因，以超过4GB / s的速度访问内存，转储到磁盘的速度较慢
这怎么可能？ 简而言之 - 在PML4自引用条目中，User/Supervisor权限位已设置为User。这使得页表在每个进程中都可用于用户模式代码。页面表通常只能由内核本身访问。
PML4是4级内存页表层次结构的基础，CPU内存管理单元（MMU）用来将进程的虚拟地址转换为RAM中的物理内存地址。欲了解更多有关寻呼的深入信息，请看看获得物理：极端滥用基于英特尔的寻呼系统 - 第1部分和第2部分。 位于偏移量0xF68且值为0x0000000062100867的PML4自引用条目。
Windows在这个最重要的PML4页表中有一个特殊的条目，它引用了它自己的一个自引用条目。在Windows 7中，PML4自引用固定在位置0x1ED，偏移量0xF68（在Windows 10中随机化）。这意味着PML4将始终映射到虚拟内存中的地址0xFFFFF6FB7DBED000。这通常是一个内核地址（Supervisor）提供的内存地址。由于权限位被错误地设置为用户，这意味着PML4被映射到每个进程并且可用于在用户模式下执行的代码。
作为用户模式读/写页面映射到每个进程的“内核地址”内存地址。.
一旦对页表进行读/写访问，除非通过用于虚拟化的扩展页表（EPT）进行额外保护，否则访问整个物理内存将非常容易。所有人都必须将自己的页面表项（PTE）写入页表以访问任意的物理内存。
PML4e 0x0000000062100867中的最后一个&#39;7&#39;（来自上面的例子）表示位0,1,2被设置，这意味着它可以按照Intel手册中的说明进行存在，可写和用户模式访问。 摘自英特尔手册，如果位2设置为&#39;1&#39;，则允许用户模式访问。
我可以自己尝试一下吗？ 是的，一点没错。 该技术已被添加为PCILeech直接存储器访问攻击工具包的内存采集设备。 只需下载PCILeech并使用设备类型执行即可：-device totalmeltdown在易受攻击的Windows 7系统上。
使用以下命令将内存转储到文件：
pcileech.exe dump -out memorydump.raw -device totalmeltdown -v -force 如果安装了Dokany文件系统驱动程序，则应该能够将正在运行的进程挂载为内存进程文件系统中的文件和文件夹 - 将内核的虚拟内存和进程的内存作为读/写进行安装。
要挂载进程，请执行以下命令：
pcileech.exe mount -device totalmeltdown 如果您暂时卸载最新版本以测试此漏洞，请记住重新安装安全更新。
易受攻击的系统被“利用”，运行中的进程被PCILeech挂载。进程内存映射和PML4被访问。
我的系统很脆弱吗？ 只有使用2018-01或2018-02补丁修补的Windows 7 x64系统才容易受到攻击。如果您的系统自2017年12月以来没有进行过修补，或者修补了2018-03修补程序或更高版本，那么它将是安全的。
其他Windows版本 - 例如Windows 10或8.1，对于这个问题是完全安全的，并且从未受到它的影响。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>

<body>
    <div class="header-placeholder"></div>
    
    <header class="header">
        <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    
    <a class="site-title" href="https://getshe11.com/">F0rmat</a>
    
    <nav class="site-nav">
        <a class="page-link" href="/">Home</a><a class="page-link" href="/post/">Category</a>
    </nav>
</div>

    </header>

    
    <div class="page-content">
        <div class="wrapper">
            
            <div class="col-main">
                <div class="post">
    
    <header class="post-header">
        <h1 class="post-title">漏洞预警|Windows 7 Meltdown 补丁发现漏洞，允许任意进程读写内核</h1>
        <p class="post-meta">Mar 29, 2018</p>
    </header>
    <article class="post-content">
        
        
        
        
        
        
        <h2 id="前言">前言</h2>
<p>今晚本来想养生睡个早觉的，睡前浏览了下twitter，看到大佬的高危漏洞，看着有点好笑，微软拿起自己的石头砸自己的脚操作哈哈，这个洞在27号就已经出来了。
<img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/20180329232319.png" alt=""></p>
<blockquote>
<p>今年1月份英特尔确认了在自家CPU中发现两个安全漏洞，而这些漏洞将会使得数十亿设备面临受到攻击的风险“Meltdown”和“Spectre”两个漏洞让不少人感觉恐慌，因为他们发现这些漏洞几乎影响到过去20年制造的每一种计算设备，无论是手机还是个人电脑。他们允许恶意程序窃取在受影响机器上处理的敏感数据。</p>
</blockquote>
<p>别以为安装这个官方的补丁就很安全了，更糟糕的事情来了，<code>这个漏洞可以允许任意进程读写内核</code>。</p>
<h2 id="总体崩溃">总体崩溃?</h2>
<p>你认为<a href="https://meltdownattack.com/">Meltdown</a>糟糕吗？未授权的应用程序能够以每秒兆字节的速度读取内核内存不是一件好事。</p>
<p>从1月份开始迎接Windows 7 Meltdown补丁。它停止了Meltdown，但是开辟了一条更糟的漏洞&hellip;&hellip;它允许任何进程以每秒千兆字节的速度读取完整的内存内容，噢 - 也可以写入任意内存。</p>
<!-- raw HTML omitted -->
<p>没有fancy的利用需要。 Windows 7已经将所需内存映射到每个正在运行的进程中。开发仅仅是读写已映射进程内虚拟内存的问题。没有fancy的API或系统调用要求 - 只是标准的读取和写入！
<img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/win7-dump-combined.png" alt="">
<code>由于磁盘传输速度的原因，以超过4GB / s的速度访问内存，转储到磁盘的速度较慢</code></p>
<h2 id="这怎么可能">这怎么可能？</h2>
<p>简而言之 - 在PML4自引用条目中，User/Supervisor权限位已设置为User。这使得页表在每个进程中都可用于用户模式代码。页面表通常只能由内核本身访问。</p>
<p>PML4是4级内存页表层次结构的基础，CPU内存管理单元（MMU）用来将进程的虚拟地址转换为RAM中的物理内存地址。欲了解更多有关寻呼的深入信息，请看看获得物理：极端滥用基于英特尔的寻呼系统 - <a href="https://www.coresecurity.com/blog/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-1">第1部分</a>和<a href="https://www.coresecurity.com/blog/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-2-windows">第2部分</a>。
<img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/win7-pml4-2.png" alt="">
<code>位于偏移量0xF68且值为0x0000000062100867的PML4自引用条目。</code></p>
<p>Windows在这个最重要的PML4页表中有一个特殊的条目，它引用了它自己的一个自引用条目。在Windows 7中，PML4自引用固定在位置0x1ED，偏移量0xF68（在Windows 10中随机化）。这意味着PML4将始终映射到虚拟内存中的地址0xFFFFF6FB7DBED000。这通常是一个内核地址（Supervisor）提供的内存地址。由于权限位被错误地设置为用户，这意味着PML4被映射到每个进程并且可用于在用户模式下执行的代码。</p>
<p><img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/win7-notepad-memmap.PNG" alt="">
<code>作为用户模式读/写页面映射到每个进程的“内核地址”内存地址。.</code></p>
<p>一旦对页表进行读/写访问，除非通过用于虚拟化的扩展页表（EPT）进行额外保护，否则访问整个物理内存将非常容易。所有人都必须将自己的页面表项（PTE）写入页表以访问任意的物理内存。</p>
<p>PML4e 0x0000000062100867中的最后一个'7'（来自上面的例子）表示位0,1,2被设置，这意味着它可以按照Intel手册中的说明进行存在，可写和用户模式访问。
<img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/win7-pml4.png" alt="">
<code>摘自英特尔手册，如果位2设置为'1'，则允许用户模式访问。</code></p>
<h2 id="我可以自己尝试一下吗">我可以自己尝试一下吗？</h2>
<p>是的，一点没错。 该技术已被添加为PCILeech直接存储器访问攻击工具包的内存采集设备。 只需下载PCILeech并使用设备类型执行即可：<code>-device totalmeltdown</code>在易受攻击的Windows 7系统上。</p>
<p>使用以下命令将内存转储到文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">pcileech.exe dump -out memorydump.raw -device totalmeltdown -v -force
</code></pre></div><p>如果安装了Dokany文件系统驱动程序，则应该能够将正在运行的进程挂载为内存进程文件系统中的文件和文件夹 - 将内核的虚拟内存和进程的内存作为读/写进行安装。</p>
<p>要挂载进程，请执行以下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">pcileech.exe mount -device totalmeltdown
</code></pre></div><p>如果您暂时卸载最新版本以测试此漏洞，请记住重新安装安全更新。</p>
<p><img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/Meltdown/win7-prsc-pcileech-mount.PNG" alt="">
<code>易受攻击的系统被“利用”，运行中的进程被PCILeech挂载。进程内存映射和PML4被访问。</code></p>
<h2 id="我的系统很脆弱吗">我的系统很脆弱吗？</h2>
<p>只有使用2018-01或2018-02补丁修补的Windows 7 x64系统才容易受到攻击。如果您的系统自2017年12月以来没有进行过修补，或者修补了2018-03修补程序或更高版本，那么它将是安全的。</p>
<p>其他Windows版本 - 例如Windows 10或8.1，对于这个问题是完全安全的，并且从未受到它的影响。</p>
<h2 id="其他">其他</h2>
<p>我在周二2018-03补丁发布补丁后发现了这个漏洞。我无法将此漏洞与已知的CVE或其他已知问题关联起来。</p>
<h2 id="更新">更新</h2>
<p>Windows 2008R2也很脆弱。
此漏洞已被清除，可以在2018-03-26上与微软安全（MSRC）博客查看。</p>
<h2 id="最后">最后</h2>
<p>小菜英文真的是抠脚，要好好学英文才行啊。</p>
<p>想知道你的 Windows 7 系统是否受到影响，可以从 Github 上下载 <a href="https://github.com/ufrisk/pcileech">PCILeech</a> 测试。</p>
<p>本文参考来源：<a href="http://blog.frizk.net/2018/03/total-meltdown.html">blog.frizk.net</a>，F0rmat译，转载请注明来源。</p>

    </article>

    
    <div class="prevnext">
        



<ul class="prevnext">
    
    <li>上一篇：
        <a href="https://getshe11.com/post/mipcms-v3.1.0-remotely-writing-the-configuration-file-getshell/">
            MIPCMS V3.1.0 远程写入配置文件Getshell(每日一洞)
        </a>
    </li>
    
    
    <li>下一篇：
        <a href="https://getshe11.com/post/oscommerce-2.3.4.1-remote-code-execution-vulnerability/">
            OsCommerce 2.3.4.1 - 远程代码执行漏洞（每日一洞）
        </a>
    </li>
    
</ul>

    </div>
    
    <div class="post-comments">
        
  
  

  
    <script src="https://utteranc.es/client.js"
            repo="F0r3at/Getshe11.com"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
</div>
            </div>
            
            <div class="col-second">
                <div class="col-box col-box-author">
    <img class="avatar" src="../../images/avatar.jpg" alt="F0rmat">
    <div class="col-box-title name">F0rmat</div>
    <p>Stay Hungry, Stay Foolish.</p>
    <p class="contact">
        <a href="http://github.com/F0r3at">Github</a>
    </p>
</div>

<div class="col-box">
    <div class="col-box-title">Newest Posts</div>
    <ul class="post-list">
        
        <li>
            <a href="https://getshe11.com/post/research-on-gitlab-cookie-deserialization-vulnerability/" class="post-link">Gitlab Cookie 反序列化漏洞研究</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/kali-install-clash/" class="post-link">Kali Linux安装Clash</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/pd-chrome-3d/" class="post-link">关于Kali2020安装Parallels Tools后Chrome显示空白</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/install-parallels-tools-on-kali-linux-2020.4/" class="post-link">Kali Linux 2020.4安装Parallels Tools</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/pathfinder/" class="post-link">Hackthebox-Pathfinder</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/domain-security/" class="post-link">Windows认证与域渗透</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/shield/" class="post-link">Hackthebox-Shield</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/archetype/" class="post-link">Hackthebox-Archetype</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/oopsie/" class="post-link">Hackthebox-Oopsie</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/vaccine/" class="post-link">Hackthebox-Vaccine</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/bc-penetration-diary/" class="post-link">Bc站渗透日记</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/maccms8-latest-command-execution-vulnerability/" class="post-link">Maccms8最新命令执行漏洞</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/seacms9.92-from-variable-override-to-getshell/" class="post-link">Seacms9.92从变量覆盖到getshell</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/seacms-front-desk-getshell/" class="post-link">Seacms&lt;=9.92前台Getshell</a>
        </li>
        
        <li>
            <a href="https://getshe11.com/post/a-difficult-penetration-process/" class="post-link">一次艰难的渗透提权过程</a>
        </li>
        
    </ul>
</div>

<div class="col-box post-toc hide">
    <div class="col-box-title">TOC</div>
</div>
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <div class="wrapper">
    © 2021    <a href="https://getshe11.com/">F0rmat</a>
</div>
    </footer>
    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@1.11.0/dist/jquery.min.js"></script>

<script src="/js/easybook.js"></script>

<script src="/js/lazysizes.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.12/dist/js/lightgallery-all.min.js"></script>
<script src="/js/figure.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-XXXXXXXX-X', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>






</body>

</html>